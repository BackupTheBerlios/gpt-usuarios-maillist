<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [gpt-usuarios] Sobre a thread &quot;o que pode ser feito com o GPT&quot;
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/gpt-usuarios/2007-September/index.html" >
   <LINK REL="made" HREF="mailto:gpt-usuarios%40lists.berlios.de?Subject=Re%3A%20%5Bgpt-usuarios%5D%20Sobre%20a%20thread%20%22o%20que%20pode%20ser%20feito%20com%20o%20GPT%22&In-Reply-To=%3C92b9a8820709031723r7bdcfd6cj63e081ff4e249adb%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <LINK REL="Previous"  HREF="000031.html">
   <LINK REL="Next"  HREF="000033.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[gpt-usuarios] Sobre a thread &quot;o que pode ser feito com o GPT&quot;</H1>
    <B>Thiago Silva</B> 
    <A HREF="mailto:gpt-usuarios%40lists.berlios.de?Subject=Re%3A%20%5Bgpt-usuarios%5D%20Sobre%20a%20thread%20%22o%20que%20pode%20ser%20feito%20com%20o%20GPT%22&In-Reply-To=%3C92b9a8820709031723r7bdcfd6cj63e081ff4e249adb%40mail.gmail.com%3E"
       TITLE="[gpt-usuarios] Sobre a thread &quot;o que pode ser feito com o GPT&quot;">tsilva em sourcecraft.info
       </A><BR>
    <I>Terça Setembro  4 02:23:00 CEST 2007</I>
    <P><UL>
        <LI>Mensagem anterior: <A HREF="000031.html">[gpt-usuarios] Sobre a thread &quot;o que pode ser feito com o GPT&quot;
</A></li>
        <LI>Próxima mensagem: <A HREF="000033.html">[gpt-usuarios] Sobre a thread &quot;o que pode ser feito com o GPT&quot;
</A></li>
         <LI> <B>Mensagens classificadas por:</B> 
              <a href="date.html#32">[ date ]</a>
              <a href="thread.html#32">[ thread ]</a>
              <a href="subject.html#32">[ subject ]</a>
              <a href="author.html#32">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 9/3/07, Alex Garzao &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/gpt-usuarios">alexgarzaol em gmail.com</A>&gt; wrote:
&gt;<i> Entendo, e acho que tanto a linguagem como o acesso a bibliotecas do sistema
</I>&gt;<i> deveriam evoluir. Eu trabalhei em um projeto de uma linguagem multiparadigma
</I>&gt;<i> (hololinguagem) durante a minha graduação. Porém, mesmo em projetos simples,
</I>&gt;<i> o que mais impactou (e impacta) o uso desta linguagem é a falta de
</I>&gt;<i> bibliotecas.
</I>
Que bom você ter background em design e implementação de linguagens.
Espero que seu know how seja bem aproveitado aqui (estou dando uma
olhada agora na hololinguagem. Achei peculiar o fato de ter base na
filosofia holística :)

&gt;<i> Talvez seria a hora de rever se esse recurso é realmente tão significativo.
</I>&gt;<i> Talvez gerar algum tipo de código intermediário deixe o gpt mais simples e
</I>&gt;<i> mais fácil de ser expandido. Vou divagar um pouco sobre isso depois.
</I>
É. Acho que, para quaisquer efeitos, se isso tem algum propósito, este
propósito encontrou seu fim na versão atual. Eu, realmente, não
pretendo continuar com este modelo.

&gt;<i> Quanto ao kernel e ao porte para windows, entendo e concordo com você em
</I>&gt;<i> gênero, número e grau :-)
</I>&gt;<i>
</I>&gt;<i> Talvez uma solução seja gerar código para uma VM (Virtual Machine) que a
</I>&gt;<i> gente vá desenvolver ou para uma VM já existente (mono, dotnet, jvm, ...).
</I>&gt;<i>
</I>
É algo que também estou investigando. Semana passada estava à procura
de máquinas virtuais e runtimes/hosts que pudessem ser um &quot;novo lar&quot;.


&gt;<i> Bom, não vou entrar no mérito de software livre e windows (isso daria muita
</I>&gt;<i> discussão rsrsrsrs) mas, se eu tivesse escolha, manteria o gpt tanto para
</I>&gt;<i> linux como windows. Eu vejo o projeto como uma ferramenta útil para que os
</I>&gt;<i> iniciantes entendam o que é programar e consigam desenvolver pequenos (ou
</I>&gt;<i> talvez não tão pequenos) projetos. Agora, o sistema que eles estão
</I>&gt;<i> utilizando deveria ser indiferente para o projeto (se possível, claro,
</I>&gt;<i> porque as vezes as dificuldades técnicas são maiores que a &quot;boa vontade&quot;).
</I>&gt;<i> Um cenário simples, onde uma escola ganhou da prefeitura vários computadores
</I>&gt;<i> com windows (legalizado ou pirata, enfim), seria uma ótima oportunidade para
</I>&gt;<i> os alunos aprenderem o que é programar um computador. Seria difícil o
</I>&gt;<i> pessoal instalar linux só para rodar o GPT (eu acho).
</I>
Concordo. Mesmo sem pretender prejudicar os usuários e alunos que
utilizam o dito sistema proprietário, eu me sinto tentado a dar mais
brilho e suporte ao sistema livre, hehe

&gt;<i> Antes que você pergunte, não sou nenhum especialista em linux, mas sou
</I>&gt;<i> desenvolvedor C/C++ linux desde 2000. Desenvolvo muito pouca coisa para
</I>&gt;<i> windows. Antes disso desenvolvia para DOS e outras coisinhas mais antigas
</I>&gt;<i> (tô ficando velho rsrsrsrs).
</I>
Ótimo! Temos bastante a aprender com o Sr.

&gt;<i> A gente poderia começar a pensar seriamente o que seria a próxima versão do
</I>&gt;<i> gpt e tentar rever o projeto conforme essas novas metas.
</I>
É, está na hora de descobrir que novas metas são estas.

&gt;<i> Eu achei muito
</I>&gt;<i> legal o gpt, mas como você disse, eu também acho que para evoliur em alguns
</I>&gt;<i> pontos nós teríamos que abandonar algumas coisas. Como comentei no outro
</I>&gt;<i> e-mail, talvez tentar interagir mais com esse pessoal que trabalha com
</I>&gt;<i> inclusão digital para ver a opinião deles.
</I>
Eu vou ver se consigo discutir isso com alguém que possa contribuir
com alguns insights. Infelizmente, parte das referências que mais me
influenciam estão em vídeo. Particularmente, o vídeo &quot;Doing with
Images Makes Symbols&quot; do Alan Kay e &quot;Talking Turtle&quot; do Seymour Papert
(estou sem a URL deles no momento, mas podem ser encontrados no google
videos).

&gt;<i> Eu acho que a gente poderia manter essas idéias. A gente poderia continuar
</I>&gt;<i> mantendo o GPT como um compilador acessível para ser estudado e, de quebra,
</I>&gt;<i> coloca um suporte na arquitetura do projeto para que ele possa ser expandido
</I>&gt;<i> &quot;fácilmente&quot; com front-end para novas linguagens, etapas de otimização de
</I>&gt;<i> código, back-end para novas arquiteturas, ...
</I>
Gostaria de ler mais sobre suas idéias a este respeito. E também, as
do Adorilson, porque eu acho que ele gostaria de abandonar o ato de
&quot;compilar&quot; (espero que ele encontre tempo de colocar as idéias dele
por aqui).

&gt;<i> Concordo com as suas idéias, mas talvez a gente possa manter um modelo de
</I>&gt;<i> execução híbrido onde o compilador gera um código intermediário que pode
</I>&gt;<i> servir de entrada para uma VM (Virtual Machine). A VM, em termos, pode ser
</I>&gt;<i> considerada um interpretador. Seguindo as idéias de uma VM, qualquer sistema
</I>&gt;<i> que tenha o porte da VM pode executar os programas gerados para esta VM. Com
</I>&gt;<i> isso, eu acho que a gente conseguiria manter a versão para windows existente
</I>&gt;<i> hoje.
</I>
De fato, teriamos ai algumas vantagens pela rapidez com que poderiamos
oferecer recursos portáveis (GUI's, filesystem, sockets, threads,
etc), bastando criar wrappers, sem necessidade de lidarmos com a
miríade de problemas e decisões delicadas que cada um deles levanta.

&gt;<i> Bom, vou &quot;brincar&quot; um pouco com as idéias então....
</I>&gt;<i>
</I>&gt;<i> A gente poderia, sem muitos problemas (dentro do meu conhecimento), gerar
</I>&gt;<i> uma estrutura bem flexível, similar a utilizada pelo GCC. O GCC nada mais é
</I>&gt;<i> que uma coleção com vários front-ends (um para cada linguagem), onde cada
</I>&gt;<i> front-end gera um código intermediário (CI)específico do GCC que, após
</I>&gt;<i> algumas etapas, é convertido para o binário final (seja ele uma biblioteca,
</I>&gt;<i> ou executável, ....).
</I>
Engraçado, pois eu cheguei a pensar, tempos atrás, em desenvolver o
GPT como um front-end para o GCC. Fazendo isso, creio que
aproveitariamos toda uma infraestrutura estabelecida. De qualquer
forma, o que mais me preocupa é o relatório do erros. No GPT existe um
grande esforço para identificar e exibir corretamente os erros de
parsing.

Uma vez que a disponibilidade de um compilador simples já não é uma
preocupação minha, eu estaria disposto a optar por uma abordagem como
esta.

&gt;<i> A gente poderia ter uma estrutura similar com um CI indepente da linguagem
</I>&gt;<i> de origem. Com isso a gente poderia ter um front-end para portugol, um
</I>&gt;<i> front-end para aquela nova linguagem OO que estão nos seus posts, etc. Todos
</I>&gt;<i> esses front-ends gerariam um CI definido por nós. Esse CI poderia ser
</I>&gt;<i> executado por uma VM, traduzido para assembly, para C, para C++, para
</I>&gt;<i> pascal, ... Claro que, na tradução, eu acho que o código não ficaria tão
</I>&gt;<i> &quot;bonito&quot; como o código gerado pelo gpt atualmente.
</I>
Que acha de utilizar a infraestrutura do GCC? Ou tens em mente algum
benefício em particular com a sugestão acima, em contraste com o uso
do GCC?

&gt;<i> Claro que a gente teria uma meta para a próxima versão que, na minha
</I>&gt;<i> opinião, seria especificar e desenvolver a arquitetura de tudo isso, e
</I>&gt;<i> montar um front-end (para portugol) e um back-end (VM). Futuramente a gente
</I>&gt;<i> poderia desenvolver outros front-ends, back-ends, tradutores, entre outros.
</I>&gt;<i> Aliás, alguém poderia se interessar e ajudar a desenvolver o projeto também.
</I>
Acho que é um bom momento para especificar o que seria a nova
linguagem. Especialmente no que se refere a inclusão de módulos e
utilização de bibliotecas externas. Talvez, rever também os tipos (e
incluir tipos heterogêneos) e suas semânticas, e abrir um breve espaço
para sugestões.

Seria bom, também, ter alguns cases, por exemplo, alguns trechos de
código em portugol utilizando janelas, sockets, threads e demais. Isso
poderia ajudar a ver o que falta na linguagem, propriamente dita. E é
um bom momento para decidir se incorporariamos outros tipos de
construções de linguagens (experimentais ou não), ou fariamos um
&quot;portugol canonico&quot;.

Particularmente, acho que deveriamos continuar com o &quot;portugol
canonico&quot;, adicionando somente o que for necessário (em termos de
sintaxe) para que ela utilize os recursos do host/SO em que estiver
rodando. Experiências com um portugol diferente, poderiamos fazer
separadamentem, se for desejável.

&gt;<i> Utilizando as idéias do GCC a gente também estaria gerando um compilador
</I>&gt;<i> muito didático (como o GPT), que poderia inclusive ser utilizado como
</I>&gt;<i> exemplo nas disciplinas de compiladores, tradutores e afins.
</I>
Tenho minhas dúvidas se conseguiriamos fazer algo didático nesta área ;)
Acho que os aspectos da arquitetura ficariam complexos muito rápido.

&gt;<i> Os tradutores poderiam agir sobre o CI, o que poderia facilitar (e muito) a
</I>&gt;<i> tradução para outras linguagens. Porém, acho que a tradução não ficaria tão
</I>&gt;<i> clara como os exemplos que eu vi do GPT.
</I>
De fato mas, particularmente, acho que a tradução é uma thread de
baixa prioridade.

&gt;<i> O CI poderia ser o popular &quot;código de três endereços&quot;, ou algum outro que se
</I>&gt;<i> encaixe nas nossas necessidades.
</I>&gt;<i>
</I>&gt;<i> Outra possibilidade seria gerar código para uma VM existente como a VM do
</I>&gt;<i> mono (e dotnet), JVM, .... mas não sei dizer se seria uma boa idéia.
</I>
Eu não conheço os opcodes deles. Talvez, implementar o interpretador
nesses ambientes fosse mais fácil.

&gt;<i> Só sei
</I>&gt;<i> dizer que gerar código para a JVM é um trabalho chato e, em muitos casos,
</I>&gt;<i> quando você não tem um opcode apropriado, você acaba tendo que gerar
</I>&gt;<i> bibliotecas só para facilitar a tradução, e programar em Java não é bem a
</I>&gt;<i> minha praia. Bom, cada um com a sua opinião.
</I>
Também não é a minha, sinceramente. Mas, acho que o trabalho não seria
tão complexo quanto poderia ser. A linguagem portugol está mais para
um subconjunto do Java. Sequer tem um modelo de objetos. Não haveria
incompatibilidade aqui, a meu ver, o que ajudaria bastante. Creio que
não exigiria voodoo, ou massas de base de código de apoio de runtime.

&gt;<i> No framework do mono (ou dotnet) nós estaríamos &quot;aproveitando&quot; todo o
</I>&gt;<i> conjunto de bibliotecas disponíveis.
</I>
Acho que é o nosso maior prêmio.

&gt;<i> Porém, pelo que eu saiba, a
</I>&gt;<i> implementação das classes no Mono não estão completas, o que poderia gerar
</I>&gt;<i> problemas para nós.
</I>
Se eu tivesse que escolher uma VM, infelizmente, eu iria com a JVM.

&gt;<i> Quanto as bibliotecas de sistema, se a idéia do Portugol é ser um ambiente
</I>&gt;<i> para aprendizado, talvez a gente não precise fornecer ao usuário a
</I>&gt;<i> possibilidade de utilizar qualquer biblioteca. Talvez seria mais
</I>&gt;<i> interessante (e mais fácil também de ser desenvolvido) a gente
</I>&gt;<i> disponibilizar as bibliotecas necessárias (sockets, threads, arquivos,
</I>&gt;<i> interface, ...) através de uma API nossa. Algo como:
</I>&gt;<i>
</I>&gt;<i>     socket := criaSocket( &quot;x.x.x.x&quot; );
</I>
Definitivamente. Porém, contudo e todavia, é aí que outra preocupação
minha aparece. É muito frustrante a experiência de querer saber o que
&quot;criaSocket&quot; faz e, ao abrir o arquivo que a contém, ver uma série de
códigos (ou uma pequena linha críptica) que não estão escritos em
portugol (ou assembly, que seria bem melhor).

&gt;<i> Como a meta do projeto não é alto desempenho, poderíamos pensar em um bind
</I>&gt;<i> dinâmico de bibliotecas, algo como carregar a biblioteca durante a execução,
</I>&gt;<i> montar os parâmetros e interpretar a resposta, tudo durante a execução. Isso
</I>&gt;<i> facilitaria a tradução para outras linguagens (acho).
</I>&gt;<i>
</I>&gt;<i> Muitas idéias hehehe.
</I>
Haha. Ótimo. Vamos ver onde isso vai dar ;)

PS: Desculpem se houverem erros (no email anterior, várias frases
ficaram estranhas). É que ando respondendo estes emails na sala de
aula com um pouco de pressa sem revisar.

-- 
Thiago Silva,
mailto: <A HREF="https://lists.berlios.de/mailman/listinfo/gpt-usuarios">tsilva em sourcecraft.info</A>
jabber: <A HREF="https://lists.berlios.de/mailman/listinfo/gpt-usuarios">tsilva em jabber.org</A>
<A HREF="http://sourcecraft.info/blog">http://sourcecraft.info/blog</A>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Mensagem anterior: <A HREF="000031.html">[gpt-usuarios] Sobre a thread &quot;o que pode ser feito com o GPT&quot;
</A></li>
	<LI>Próxima mensagem: <A HREF="000033.html">[gpt-usuarios] Sobre a thread &quot;o que pode ser feito com o GPT&quot;
</A></li>
         <LI> <B>Mensagens classificadas por:</B> 
              <a href="date.html#32">[ date ]</a>
              <a href="thread.html#32">[ thread ]</a>
              <a href="subject.html#32">[ subject ]</a>
              <a href="author.html#32">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/gpt-usuarios">Mais detalhes sobre a lista de discuss&atilde;o Gpt-usuarios
</a><br>
</body></html>
