<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [gpt-usuarios] coringa
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/gpt-usuarios/2007-December/index.html" >
   <LINK REL="made" HREF="mailto:gpt-usuarios%40lists.berlios.de?Subject=Re%3A%20%5Bgpt-usuarios%5D%20coringa&In-Reply-To=%3C9a3912af0712220357x392e8555kbd5b64ccf59d4d88%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <LINK REL="Previous"  HREF="000719.html">
   <LINK REL="Next"  HREF="000730.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[gpt-usuarios] coringa</H1>
    <B>Alex Garzao</B> 
    <A HREF="mailto:gpt-usuarios%40lists.berlios.de?Subject=Re%3A%20%5Bgpt-usuarios%5D%20coringa&In-Reply-To=%3C9a3912af0712220357x392e8555kbd5b64ccf59d4d88%40mail.gmail.com%3E"
       TITLE="[gpt-usuarios] coringa">alexgarzaol em gmail.com
       </A><BR>
    <I>Sábado Dezembro 22 12:57:29 CET 2007</I>
    <P><UL>
        <LI>Mensagem anterior: <A HREF="000719.html">[gpt-usuarios] coringa
</A></li>
        <LI>Próxima mensagem: <A HREF="000730.html">[gpt-usuarios] coringa
</A></li>
         <LI> <B>Mensagens classificadas por:</B> 
              <a href="date.html#727">[ date ]</a>
              <a href="thread.html#727">[ thread ]</a>
              <a href="subject.html#727">[ subject ]</a>
              <a href="author.html#727">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i>
</I>&gt;<i> Estava refletindo sobre o tipo &quot;coringa&quot; e acho que podemos
</I>&gt;<i> descartá-lo, utilizando algo mais &quot;seguro&quot;.
</I>

Mas internamente (VM e talvez GptAssembly) a gente continuaria tratando como
um tipo inteiro ?

A idéia deste tipo era poder receber qualquer valor e poder lidar,
&gt;<i> principalmente, com tipos oriundos da linguagem C.
</I>

Isso mesmo.


&gt;<i> Como até o momento
</I>&gt;<i> não tinhamos uma especificação mais concreta de como os bindings
</I>&gt;<i> funcionariam, o &quot;coringa&quot; funcionou meio como um &quot;tapa buraco&quot;
</I>&gt;<i> enquanto a idéia se formava. Tampando o buraco de um lado, ele abriria
</I>&gt;<i> outros, por outro lado, como a provavel dificuldade em implementar as
</I>&gt;<i> atribuições que envolvem este tipo a nível de gptasm, além da abertura
</I>&gt;<i> indiscriminada no sistema de tipos, tornando-o fundamentalmente
</I>&gt;<i> inseguro.
</I>

Posso estar enganado, mas acho que a nível de gptassembly não temos
problemas para implementar as atribuições.

Mas quanto ao sistema de tipos, sim, isso o torna inseguro. O que está sendo
utilizado é um tipo &quot;pointer&quot;, mas sem definição do que ele aponta. Seria o
equivalente a um &quot;void*&quot; em C.


Pensei, portanto, em aposentar a idéia deste tipo e implementar algo
&gt;<i> como um &quot;typedef&quot;, onde este operador criasse um novo tipo a partir de
</I>&gt;<i> um existente, sem manter a equivalência semântica com o tipo origem.
</I>&gt;<i>
</I>&gt;<i> por exemplo:
</I>&gt;<i>
</I>&gt;<i> tipo janela é inteiro;
</I>

Quem sabe &quot;tipo janela é pointer;&quot; ? Já temos o pointer. Meu receio
basicamente é que, por enquanto, não tem problema de aproximarmos um pointer
para inteiro, mas vai que em alguma arquitetura isso não seja correto.
Lembro que trabalhei com porte de aplicativos do IA32 para o IA64 em 2001 e
uma das regras era essa (nunca aproximar um pointer para inteiro e
vice-versa).

Isso definiria o tipo &quot;janela&quot; como um novo tipo, com as mesmas
&gt;<i> características de armazenamento de um inteiro (por ex. 4 bytes de
</I>&gt;<i> tamanho), mas não permitiria que uma variável do tipo janela fosse
</I>&gt;<i> utilizada onde um inteiro é utilizado:
</I>

Isso seria interessante (semanticamente falando).


&gt;<i> variável x : janela;
</I>&gt;<i>
</I>&gt;<i> x := 10 + x; //erro!
</I>&gt;<i>
</I>&gt;<i> O motivo por traz disso é permitir que o tipo &quot;janela&quot; seja passado
</I>&gt;<i> como parâmetro apenas para as funções que recebem este tipo de
</I>&gt;<i> parâmetro.
</I>

Ficaria muito bom.


&gt;<i> O motivo real, então, do operador &quot;tipo&quot;, é auxiliar a
</I>&gt;<i> criação de tipos nos bindings, especialmente para bibliotecas que se
</I>&gt;<i> utilizam muito de typedefs para ponteiros, de forma segura.
</I>

Esse ponto eu não entendi...

[]'s
Alex Sandro Garzão
-------------- Próxima Parte ----------
Um anexo em HTML foi limpo...
URL: &lt;<A HREF="https://lists.berlios.de/pipermail/gpt-usuarios/attachments/20071222/38d8aafa/attachment.html">https://lists.berlios.de/pipermail/gpt-usuarios/attachments/20071222/38d8aafa/attachment.html</A>&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Mensagem anterior: <A HREF="000719.html">[gpt-usuarios] coringa
</A></li>
	<LI>Próxima mensagem: <A HREF="000730.html">[gpt-usuarios] coringa
</A></li>
         <LI> <B>Mensagens classificadas por:</B> 
              <a href="date.html#727">[ date ]</a>
              <a href="thread.html#727">[ thread ]</a>
              <a href="subject.html#727">[ subject ]</a>
              <a href="author.html#727">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/gpt-usuarios">Mais detalhes sobre a lista de discuss&atilde;o Gpt-usuarios
</a><br>
</body></html>
